r"""
fgmax_tools module: $CLAW/geoclaw/src/python/geoclaw/fgmax_tools.py

Tools to specify an fgmax grid for keeping track of maximum flow depth, etc.
and to read in the fgmax output after doing a GeoClaw run.

"""

from __future__ import absolute_import
from __future__ import print_function
from clawpack.geoclaw import kmltools
import os
from numpy import sqrt, ma
import numpy
from six.moves import range
#from clawpack.geoclaw import topotools
import topotools # local version with masked write



class FGmaxGrid(object):

    """
    New class introduced in 5.2.1 to keep store information both about the
    fgmax input data and the output generated by a GeoClaw run.
    """

    def __init__(self):
        
        # GeoClaw input values:
        self.point_style = None
        self.npts = None
        self.nx = None
        self.ny = None
        self.n12 = None
        self.n23 = None
        self.tstart_max =  0.
        self.tend_max = 1.e10   # when to stop monitoring max values
        self.dt_check = 10.     # target time (sec) increment between updating 
                                # max values
        self.min_level_check = None    # which levels to monitor max on
        self.arrival_tol = 1.e-2       # tolerance for flagging arrival
        self.input_file_name = 'fgmax.txt'  # file for GeoClaw input data
        self.fgno = 1  # FG number
        self.xy_fname = None   # optional file name for separate list of points
                             # when point_style==0, distinct from header file
        self.write_xy_fname = False # controls whether xy_fname is created
                                    # by self.write_input_data, or only header
                                    
        # Other possible GeoClaw inputs:
        self.x = None
        self.y = None
        self.X = None
        self.Y = None
        self.Z = None  # for topo DEM values if available
        self.fgmax_point = None  # for point_style==4
        self.force_dry_init = None  # =1 if wet, =0 if dry
        self.dx = None
        self.dy = None 

        # possible output values that may be available after run:
        self.outdir = '_output'    # where to find GeoClaw output fort.FG*
        self.level = None
        self.X = None
        self.Y = None
        self.Z = None
        self.dx = None
        self.dy = None
        self.B = None
        self.h = None
        self.h_time = None
        self.s = None
        self.s_time = None
        self.hs = None
        self.hs_time = None
        self.hss = None
        self.hss_time = None
        self.hmin = None
        self.hmin_time = None
        self.arrival_time = None
        
        # possible derived quantities of interest:
        self.dz = None
        self.B0 = None
        self.eta = None
        self.h_onshore = None
        self.id = ''  # identifier
        self.label = ''  # text for legend


    def read_input_data(self, input_file_name=None):
        r"""
        Read input data from a file like *fgmax.txt* that
        might have been created by *write_input_data*.
        """

        if input_file_name is not None:
            self.input_file_name = input_file_name
        fgmax_input = open(self.input_file_name).readlines()

        self.tstart_max = float(fgmax_input[0].split()[0])
        self.tend_max = float(fgmax_input[1].split()[0])
        self.dt_check = float(fgmax_input[2].split()[0])
        self.min_level_check = int(fgmax_input[3].split()[0])
        self.arrival_tol = float(fgmax_input[4].split()[0])
        self.point_style = point_style = int(fgmax_input[5].split()[0])
        if point_style == 0:
            self.npts = npts = int(fgmax_input[6].split()[0])
            if npts == 0:
                self.xy_fname = fgmax_input[7][1:-2]  # strip quotes
                xy = numpy.loadtxt(self.xy_fname, skiprows=1)
                self.X = xy[:,0]
                self.Y = xy[:,1]
                if xy.shape[1] > 2:
                    self.Z = xy[:,2]  # in case DEM values also stored in input file
                else:
                    self.Z = None
                self.npts = npts = len(self.X)
                print('Read %i x,y points from \n    %s' % (npts, self.xy_fname))
            else:
                self.X, self.Y = numpy.loadtxt(fgmax_input, skiprows=7, unpack=True)
        elif point_style == 1:
            self.npts = npts = int(fgmax_input[6].split()[0])
            self.x1 = float(fgmax_input[7].split()[0])
            self.y1 = float(fgmax_input[7].split()[1])
            self.x2 = float(fgmax_input[8].split()[0])
            self.y2 = float(fgmax_input[8].split()[1])
        elif point_style == 2:
            self.nx = nx = int(fgmax_input[6].split()[0])
            self.ny = ny = int(fgmax_input[6].split()[1])
            self.x1 = float(fgmax_input[7].split()[0])
            self.y1 = float(fgmax_input[7].split()[1])
            self.x2 = float(fgmax_input[8].split()[0])
            self.y2 = float(fgmax_input[8].split()[1])
        elif point_style == 3:
            self.n12 = n12 = int(fgmax_input[6].split()[0])
            self.n23 = n23 = int(fgmax_input[6].split()[1])
            self.x1 = float(fgmax_input[7].split()[0])
            self.y1 = float(fgmax_input[7].split()[1])
            self.x2 = float(fgmax_input[8].split()[0])
            self.y2 = float(fgmax_input[8].split()[1])
            self.x3 = float(fgmax_input[9].split()[0])
            self.y3 = float(fgmax_input[9].split()[1])
            self.x4 = float(fgmax_input[10].split()[0])
            self.y4 = float(fgmax_input[10].split()[1])
        elif point_style == 4:
            self.xy_fname = fgmax_input[6][1:-2]  # strip quotes
            ## Need to read in topotype 3 file and set self.npts
            # xy = numpy.loadtxt(self.xy_fname, skiprows=1)
            # self.X = xy[:,0]
            # self.Y = xy[:,1]
            # if xy.shape[1] > 2:
            #     self.Z = xy[:,2]  # in case DEM values also stored in input file
            # else:
            #     self.Z = None
            # self.npts = npts = len(self.X)
            # print('Read %i x,y points from \n    %s' % (npts, self.xy_fname))

    def write_input_data(self, input_file_name=None):
        r"""
        Write input data to a file like *fgmax.txt* that
        will be read in by GeoClaw as input data.
        """

        if input_file_name is not None:
            self.input_file_name = input_file_name

        print("---------------------------------------------- ")
        point_style = self.point_style
        if point_style not in [0,1,2,3,4]:
            raise NotImplementedError("make_fgmax not implemented for point_style %i" \
                % point_style)

        # write header, independent of point_style:
        fid = open(self.input_file_name,'w')
        fid.write("%16.10e            # tstart_max\n"  % self.tstart_max)
        fid.write("%16.10e            # tend_max\n"  % self.tend_max)
        fid.write("%16.10e            # dt_check\n" % self.dt_check)
        fid.write("%i %s              # min_level_check\n" \
                            % (self.min_level_check,16*" "))

        fid.write("%16.10e            # arrival_tol\n" % self.arrival_tol)
        fid.write("%i %s              # point_style\n" \
                            % (self.point_style,16*" "))


        if point_style == 0:
            if self.xy_fname is not None:
                fid.write("0         # npts==0 ==> points in this file:\n")
                fid.write("'%s'\n" % self.xy_fname)
                print("Created header file only, points should be in file:")
                print("   %s" % self.xy_fname)
                if self.write_xy_fname:
                    if self.Z is not None:
                        xydata = numpy.vstack([self.X,self.Y,self.Z]).T
                    else:
                        xydata = numpy.vstack([self.X,self.Y])
                    numpy.savetxt(self.xy_fname, xydata, 
                                  header='%8i' % len(self.X), 
                                  comments='', fmt='%24.14e')
            else:
                # list of points
                npts = self.npts
            
                print("Creating unstructured grid of %s points" % npts)
            
                fid.write("%i                 # npts\n" % (npts))
                for k in range(npts):
                    fid.write("%22.12f   %22.12f \n" % (self.X[k],self.Y[k]))
            fid.close()
            
            print("Created file ", self.input_file_name)
            

        elif point_style==1:
            # 1d transect of points
            x1,x2 = self.x1, self.x2
            y1,y2 = self.y1, self.y2
            if self.npts is None:
                dx = self.dx
                npts = int(round(sqrt((x2-x1)**2 + (y2-y1)**2)/dx)) + 1
                if abs((npts-1)*dx + x1 - x2) > 1e-6:
                    print("Warning: abs((npts-1)*dx + x1 - x2) = ", \
                          abs((npts-1)*dx + x1 - x2))
                    x2 = x1 + dx*(npts-1)
                    y2 = y1 + dx*(npts-1)
                    print("         resetting x2 to %g" % x2)
                    print("         resetting y2 to %g" % y2)
            else:
                npts = self.npts
                dx = sqrt((x2-x1)**2 + (y2-y1)**2)/(npts+1.)
                if self.dx is not None:
                    print("*** Warning: dx specified over-ridden by: ",dx)
        
        
            print("Creating 1d fixed grid with %s points" % npts)
            print("   dx = %g" % dx)
        
        
            fid.write("%i                 # npts\n" % (npts))
            fid.write("%g   %g            # x1, y1\n" % (x1,y1))
            fid.write("%g   %g            # x2, y2\n" % (x2,y2))
            fid.close()
            
        
            print("Created file ", self.input_file_name)
            print("   specifying fixed grid with %i points equally spaced from " \
                    % npts)
            print("   (%g,%g)  to  (%g,%g)" % (x1,y1,x2,y2))
            
            # not yet implemented:
            #fname_root = os.path.splitext(self.input_file_name)[0]
            #kml_file = fname_root + '.kml'
            #kmltools.line2kml(xy, kml_file, fname_root, color='8888FF')

        if point_style == 2:
            # 2d grid of points
            x1,x2 = self.x1, self.x2
            y1,y2 = self.y1, self.y2
            if self.nx is None:
                dx = self.dx
                nx = int(round((x2-x1)/dx)) + 1  
                if abs((nx-1)*dx + x1 - x2) > 1e-6:
                    print("Warning: abs((nx-1)*dx + x1 - x2) = ", \
                          abs((nx-1)*dx + x1 - x2))
                    print("         old x2: %22.16e" % x2)
                    x2 = x1 + dx*(nx-1)
                    print("         resetting x2 to %22.16e" % x2)
            else:
                nx = self.nx
                dx = (x2-x1)/(nx+1.)
                if self.dx is not None:
                    print("*** Warning: dx specified over-ridden by: ",dx)
        
            if self.ny is None:
                dy = self.dy
                if dy is None:
                    dy = dx
                ny = int(round((y2-y1)/dy)) + 1  
                if abs((ny-1)*dy + y1 - y2) > 1e-6:
                    print("Warning: abs((ny-1)*dy + y1 - y2) = ", \
                          abs((ny-1)*dy + y1 - y2))
                    print("         old y2: %22.16e" % y2)
                    y2 = y1 + dy*(ny-1)
                    print("         resetting y2 to %22.16e" % y2)
            else:
                ny = self.ny
                dy = (y2-y1)/(ny+1.)
                if self.dy is not None:
                    print("*** Warning: dy specified over-ridden by: ",dy)
        
        
            npts = nx*ny
        
        
            fid.write("%i  %i %s          # nx,ny\n" \
                                % (nx,ny,10*" "))
            fid.write("%16.10e   %20.10e            # x1, y1\n" % (x1,y1))
            fid.write("%16.10e   %20.10e            # x2, y2\n" % (x2,y2))
            fid.close()
            
        
            print("Created file ", self.input_file_name)
            print("   specifying fixed grid with shape %i by %i, with  %i points" \
                    % (nx,ny,npts))
            print("   lower left  = (%15.10f,%15.10f)" % (x1,y1))
            print("   upper right = (%15.10f,%15.10f)" % (x2,y2))
            print("   dx = %15.10e,  dy = %15.10e" % (dx,dy))
        
            xy = [x1,x2,y1,y2]
            fname_root = os.path.splitext(self.input_file_name)[0]
            kml_file = fname_root + '.kml'
            kmltools.box2kml(xy, kml_file, fname_root, color='8888FF')

        elif point_style==3:
            # arbitrary quadrilateral
            x1,x2 = self.x1, self.x2
            y1,y2 = self.y1, self.y2
            x3,x4 = self.x3, self.x4
            y3,y4 = self.y3, self.y4
            if self.n12 is None:
                raise NotImplementedError("Need to set n12 and n23")
            else:
                npts = self.n12 * self.n23
        
            fid.write("%i  %i %s          # self.n12,self.n23\n" \
                                % (self.n12,self.n23,10*" "))
            fid.write("%16.10e   %20.10e            # x1, y1\n" % (x1,y1))
            fid.write("%16.10e   %20.10e            # x2, y2\n" % (x2,y2))
            fid.write("%16.10e   %20.10e            # x3, y3\n" % (x3,y3))
            fid.write("%16.10e   %20.10e            # x4, y4\n" % (x4,y4))
            fid.close()
            
        
            print("Created file ", self.input_file_name)
            print("   specifying fixed grid as a quadrilateral")
            print("       %i by %i, with  %i points" \
                    % (self.n12,self.n23,npts))
            print("   corner 1 = (%15.10f,%15.10f)" % (x1,y1))
            print("   corner 2 = (%15.10f,%15.10f)" % (x2,y2))
            print("   corner 3 = (%15.10f,%15.10f)" % (x3,y3))
            print("   corner 4 = (%15.10f,%15.10f)" % (x4,y4))
            
            xy = [x1,y1,x2,y2,x3,y3,x4,y4]
            fname_root = os.path.splitext(self.input_file_name)[0]
            kml_file = fname_root + '.kml'
            kmltools.quad2kml(xy, kml_file, fname_root, color='8888FF')
            
        elif point_style == 4:
            if self.xy_fname is not None:
                fid.write("'%s'\n" % self.xy_fname)
                print("Created header file only, points should be in file:")
                print("   %s" % self.xy_fname)
                fid.close()

    def read_output(self, fgno=None, outdir=None):
        r"""
        Read the GeoClaw results on the fgmax grid numbered *fgno*.
        """
    
        if self.point_style is None:
            raise IOError("*** point_style is not set, need to read input?")
        point_style = self.point_style

        if fgno is not None:
            self.fgno = fgno
        if outdir is not None:
            self.outdir = outdir
    
        # try new style, e.g. fort.FG0001.valuemax
        fname1 = os.path.join(self.outdir, 'fort.FG%s' \
                % str(self.fgno).zfill(4))
        if os.path.isfile(fname1):
            fname_style = 'new'
            fname = fname1
        else:
            # try old style, e.g. fort.FG1.valuemax
            fname2 = os.path.join(self.outdir, 'fort.FG%s.valuemax' \
                % str(self.fgno))
            fname_style = 'old'
            fname = fname2
            if not os.path.isfile(fname2):
                raise IOError("File not found: %s or %s" % (fname1,fname2))

        print("Reading %s ..." % fname)
        d = numpy.loadtxt(fname)
        
        if point_style == 4:
            self.npts = d.shape[0]
            print('+++ point_style == 4, found %i points ' % self.npts)

                    
        if fname_style == 'new':
            # includes column for B = topo from aux array
            cols_expected = [7,9,15]  
        else:
            cols_expected = [6,8,14]
            
        ncols = d.shape[1]
        
        if ncols not in cols_expected:
            raise IOError("*** Unexpected number of columns %s in file %s" \
                    % (ncols, fname))
    
        ind_s = None
        ind_hs = None
        ind_hss = None
        ind_hmin = None
        ind_h_time = None
        ind_s_time = None
        ind_hs_time = None
        ind_hss_time = None
        ind_hmin_time = None
        
        if fname_style == 'new':
            ind_x = 0
            ind_y = 1
            ind_level = 2
            ind_B = 3  # added in new fname style
            ind_h = 4
            if ncols == 7:
                ind_h_time = 5
                ind_arrival_time = 6
            elif ncols == 9:
                ind_s = 5
                ind_h_time = 6
                ind_s_time = 7
                ind_arrival_time = 8
            elif ncols == 15:
                ind_s = 5
                ind_hs = 6
                ind_hss = 7
                ind_hmin = 8
                ind_h_time = 9
                ind_s_time = 10
                ind_hs_time = 11
                ind_hss_time = 12
                ind_hmin_time = 13
                ind_arrival_time = 14
        else:
            # original style:
            ind_x = 0
            ind_y = 1
            ind_level = 2
            ind_h = 3
            if ncols == 6:
                ind_h_time = 4
                ind_arrival_time = 5
            elif ncols == 8:
                ind_s = 4
                ind_h_time = 5
                ind_s_time = 6
                ind_arrival_time = 7
            elif ncols == 14:
                ind_s = 4
                ind_hs = 5
                ind_hss = 6
                ind_hmin = 7
                ind_h_time = 8
                ind_s_time = 9
                ind_hs_time = 10
                ind_hss_time = 11
                ind_hmin_time = 12
                ind_arrival_time = 13
    
        if point_style in [0,1,4]:
            fg_shape = (self.npts,)
        elif point_style == 2:
            fg_shape = (self.nx,self.ny)
        elif point_style == 3:
            fg_shape = (self.n12,self.n23)
        else:
            raise NotImplementedError("Not implemented for point_style %s" \
                % point_style)
    
        X = numpy.reshape(d[:,0],fg_shape,order='F')
        Y = numpy.reshape(d[:,1],fg_shape,order='F')
        y0 = 0.5*(Y.min() + Y.max())   # mid-latitude for scaling plots
        h = numpy.reshape(d[:,ind_h],fg_shape,order='F')
    
        # AMR level used for each fgmax value:
        level = numpy.reshape(d[:,ind_level].astype('int'),fg_shape,order='F')
        
        # Set B = topo array
        if fname_style == 'new':
            B = numpy.reshape(d[:,ind_B],fg_shape,order='F')
        else:
            # old style was to read all aux arrays and select proper column
            fname = os.path.join(self.outdir, 'fort.FG%s.aux1' \
                    % str(self.fgno))

            if not os.path.isfile(fname):
                raise IOError("File not found: %s" % fname)

            print("Reading %s ..." % fname)
            daux = numpy.loadtxt(fname,comments='#')
        
            ncols = d.shape[1]  
                
            topo = []
            nlevels = daux.shape[1]
            for i in range(2,nlevels):
                topoi = numpy.reshape(daux[:,i],fg_shape,order='F')
                topoi = ma.masked_where(topoi < -1e50, topoi)
                topo.append(topoi)
        
            B = ma.masked_where(level==0, topo[0])  # level==0 ==> never updated
            levelmax = level.max()
            for i in range(levelmax):
                B = numpy.where(level==i+1, topo[i], B)
    
    
        mask = (h < -1e50)  # points that were never set
        B = ma.masked_where(mask, B)
        h = ma.masked_where(mask, h)

        def set_q_time(ind_q, ind_q_time):  
            q = numpy.reshape(d[:,ind_q],fg_shape,order='F')
            q = ma.masked_where(mask,q) 
            q_time = numpy.reshape(d[:,ind_q_time],fg_shape,order='F')  
            q_time = ma.masked_where(mask, q_time)      
            return q, q_time
    
        self.h, self.h_time = set_q_time(ind_h, ind_h_time)
        if ind_s:
            self.s, self.s_time = set_q_time(ind_s, ind_s_time)
        if ind_hs:
            self.hs, self.hs_time = set_q_time(ind_hs, ind_hs_time)
            self.hss, self.hss_time = set_q_time(ind_hss, ind_hss_time)
            self.hmin, self.hmin_time = set_q_time(ind_hmin, ind_hmin_time)
    
        # last column is arrival times:
        arrival_time = numpy.reshape(d[:,ind_arrival_time],fg_shape,order='F')
        arrival_time = ma.masked_where(arrival_time < -1e50, arrival_time)  
        arrival_time = ma.masked_where(mask, arrival_time)
        self.arrival_time = arrival_time
    
        self.level = level
        self.X = X
        self.Y = Y
        self.B = B
        self.h = h
        
        self.B0 = B  ## SHOULD MODIFY BY dz!
        
        if self.force_dry_init is not None:
            self.h_onshore = ma.masked_where(self.force_dry_init==0, self.h)
        else:
            self.h_onshore = ma.masked_where(self.B0 < 0., self.h)

    def bounding_box(self):
        x1 = self.X.min()
        x2 = self.X.max()
        y1 = self.Y.min()
        y2 = self.Y.max()
        return [x1,x2,y1,y2]
        
    def convert_lists_to_arrays(self,dx,dy):
        
        assert self.point_style in [0,2,4], '*** Require self.point_style in [0,2,4]'
        
        x_1d = self.X
        y_1d = self.Y
        print('+++ x_1d.shape = ', x_1d.shape)
        z_1d_arrays = [self.level, self.B, self.h, self.h_time, self.s, self.s_time, 
                       self.hs, self.hs_time, self.hss, self.hss_time, self.hmin, 
                       self.hmin_time, self.arrival_time]
        num_arrays = len(z_1d_arrays)
        if self.Z is not None:
            z_1d_arrays.append(self.Z)
                       
        X,Y,Z_arrays = lists_to_arrays(x_1d, y_1d, z_1d_arrays, dx, dy)
        print('+++X.shape = ', X.shape)
        
        # unpack:
        self.level, self.B, self.h, self.h_time, self.s, self.s_time, \
                self.hs, self.hs_time, self.hss, self.hss_time, self.hmin, \
                self.hmin_time, self.arrival_time = Z_arrays[:num_arrays]
        self.X = X
        self.Y = Y
        if self.Z is not None:
            self.Z = Z_arrays[-1]
                

def adjust_fgmax_1d(x1_desired, x2_desired, x1_domain, dx):
    """
    :Input:
     - x1_desired, x2_desired: approximate desired limits of fgmax grid
     - x1_domain:  lower edge of computational domain
     - dx: Mesh spacing on fine grid that fgmax grid should conform to
    :Output:
     - x1_new, x2_new: limits to set so (x2-x1) is integer multiple
       of dx and points are at cell centers of computational grid
     - npoints: number of points
    """

    i1 = numpy.floor((x1_desired-x1_domain - 0.5*dx)/dx)
    x1_new = x1_domain + (i1 + 0.5)*dx 
    i2 = numpy.floor((x2_desired-x1_domain + 0.5*dx)/dx)
    x2_new = x1_domain + (i2 + 0.5)*dx 
    npoints = int(i2 - i1) + 1
    return x1_new, x2_new, npoints


def adjust_fgmax_grid(x1_desired, x2_desired, x1_domain, dx,
                      y1_desired, y2_desired, y1_domain, dy=None, verbose=True):

    
    if dy == None:
        dy = dx

    x1_new, x2_new, nx = adjust_fgmax_1d(x1_desired, x2_desired, x1_domain, dx)
    y1_new, y2_new, ny = adjust_fgmax_1d(y1_desired, y2_desired, y1_domain, dy)

    if verbose:
        print("x:")
        print("  moved %17.12f to %17.12f by %g" % (x1_desired, x1_new, abs(x1_desired-x1_new)))
        print("  moved %17.12f to %17.12f by %g" % (x2_desired, x2_new, abs(x2_desired-x2_new)))
        print("y:")
        print("  moved %17.12f to %17.12f by %g" % (y1_desired, y1_new, abs(y1_desired-y1_new)))
        print("  moved %17.12f to %17.12f by %g" % (y2_desired, y2_new, abs(y2_desired-y2_new)))
        #print "  "
        #print "fg.nx = %g" % nx
        #print "fg.ny = %g" % ny
        #print "fg.x1 = %17.12f" % x1_new
        #print "fg.x2 = %17.12f" % x2_new
        #print "fg.y1 = %17.12f" % y1_new
        #print "fg.y2 = %17.12f" % y2_new
    return x1_new, x2_new, nx, y1_new, y2_new, ny


def make_fgmax_points_from_topo(topo, zmin=-1e10, zmax=1e10,
                                extent='all', polygon=None, coarsen=1):
    
    """
    `polygon` can be a convex polygon of class shapely.geometry.polygon.Polygon,
    in which case only points that lie in both the xy extent specified by
    `extent` and in `polygon` will be considered.
    """

    if polygon:
        from shapely.geometry import Point
    
    fg = FGmaxGrid()
                            
    try:
        icoarsen, jcoarsen = coarsen  # if list
    except:
        icoarsen = jcoarsen = coarsen  # if single value
        
    if extent == 'all':
        x1,x2,y1,y2 = -360, 360, -90, 90
    elif extent == 'polygon':
        if polygon is not None:
            extent = polygon.bounds
            x1,x2,y1,y2 = extent  # unpack
        else:
            print("*** extent='polygon' ignored, no polygon")
    else:
        x1,x2,y1,y2 = extent  # unpack

    # find indices i,j for part of topo overlapping desired extent:
    iextent = [i for i,x in enumerate(topo.x) if (x1 <= x <= x2)]
    jextent = [j for j,y in enumerate(topo.y) if (y1 <= y <= y2)]
    
    try:
        i1 = iextent[0]
        i2 = iextent[-1] + 1
        j1 = jextent[0]
        j2 = jextent[-1] + 1
    except:
        raise ValueError('** extent does not overlap topo')

    X = topo.X[j1:j2:jcoarsen,i1:i2:icoarsen]
    Y = topo.Y[j1:j2:jcoarsen,i1:i2:icoarsen]
    Z = topo.Z[j1:j2:jcoarsen,i1:i2:icoarsen]
    
    X1d = numpy.ravel(X)
    Y1d = numpy.ravel(Y)
    Z1d = numpy.ravel(Z)

    print("From topo, found %i points in region" \
            % len(numpy.ravel(Z)))
    
    if polygon is not None:
        # mask values of Z array outside convex polygon
        points = [Point(xy) for xy in zip(X1d,Y1d)]
        inside = [polygon.contains(p) for p in points]
        Z1dm = ma.masked_where(numpy.logical_not(inside), Z1d)
    else:
        Z1dm = Z1d

    # mask values of Z array outside [zmin,zmax]:
    #Zm = ma.masked_where(numpy.logical_or(Z<zmin, Z>zmax), Z)
    #Z1dm = ma.ravel(Zm)
    Z1dm = ma.masked_where(numpy.logical_or(Z1dm<zmin, Z1dm>zmax), Z1dm)
    Zm = Z1dm.reshape(Z.shape)

    # find indices of Z1dm where not masked
    km = [kz for kz,z in enumerate(Z1dm.mask) if not z]
    
    print("Found %i points with z between zmin = %g and zmax = %g" \
            % (len(km), zmin, zmax))
    print("      in the region with extent %s" % str(extent))
    if polygon is not None:
        print("      and in the polygon:")
        for xy in polygon.boundary.coords:
            print(xy)
    
    fg.X = X1d[km]
    fg.Y = Y1d[km]
    fg.point_style = 0  # points
    fg.npts = len(fg.X)
    fg.Z = Z1d[km]  # also return the DEM topo value at each X,Y

    masked_topo = topotools.Topography()
    masked_topo._x = X[0,:]
    masked_topo._y = Y[:,0]
    masked_topo._Z = Zm  # replace by masked array
    masked_topo.generate_2d_topo()
    
    return fg, masked_topo


def plot_fgmax_points(X1,Y1,Z1,dx,dy,zmin=None,zmax=None,ax=None,
                      cmap=None,norm=None,alpha=1.,edgecolors='none',
                      title=None,cb_label=None,png_fname=None):
                      
    """
    This is *very* slow for lots of points since it creates and 
    plots a rectangle for each point, covering the appropriate area.
    
    Instead use plot_fgmax_masked_topo below for most purposes.
    """
    
    import matplotlib.pyplot as plt
    import matplotlib.colors as colors
    import clawpack.visclaw.colormaps as colormaps
    from matplotlib.collections import PatchCollection
    from matplotlib.patches import Rectangle

    print("Plotting %i fgmax_points... " % len(Z1))
    
    if ax is None:
        plt.figure(500)
        plt.clf()
        ax = plt.subplot(111)

    if zmin is None:
        zmin = Z1.min()
    
    if zmax is None:
        zmax = Z1.max()
        
    if (cmap is None) or (norm is None):
        land_cmap = colormaps.make_colormap({ 0.0:[0.1,0.4,0.0],
                                             0.25:[0.0,1.0,0.0],
                                              0.5:[0.8,1.0,0.5],
                                              1.0:[0.8,0.5,0.2]})

        sea_cmap = colormaps.make_colormap({ 0.0:[0,0,1], 1.:[.8,.8,1]})

        cmap, norm = colormaps.add_colormaps((land_cmap, sea_cmap),
                                             data_limits=(zmin,zmax),
                                             data_break=0.)


    rects = []
    for xi,yj,zij in zip(X1,Y1,Z1):
        rect = Rectangle((xi-dx/2.,yj-dy/2.), dx, dy)
        rects.append(rect)
        #ax.add_patch(rect)

    pc = PatchCollection(rects,  alpha=alpha, cmap=cmap, norm=norm,
                         edgecolor=edgecolors)
    pc.set_array(Z1)
    ax.add_collection(pc)
    cb = plt.colorbar(pc, extend='both')
    if cb_label is not None:
        cb.set_label(cb_label)

    plt.gca().set_aspect(1./numpy.cos(Y1.mean()*numpy.pi/180))
    
    x1 = X1.min() - 10*dx
    x2 = X1.max() + 10*dx
    y1 = Y1.min() - 10*dy
    y2 = Y1.max() + 10*dy
    plt.axis([x1,x2,y1,y2])
    
    plt.ticklabel_format(format='plain',useOffset=False)
    plt.xticks(rotation=20)
    if title is None:
        plt.title('%i fgmax points' % len(X1))
    else:
        plt.title(title)
        
    if png_fname is not None:
        plt.savefig(png_fname)
        print("Created %s" % png_fname)
        plt.close(500)
        

def plot_fgmax_masked_topo(masked_topo,zmin=None,zmax=None,ax=None,
                      cmap=None,norm=None,alpha=1.,edgecolors='none',
                      title=None,cb_label=None,png_fname=None):
                      
    """
    Plot the fgmax points based on the masked_topo array that is 
    masked at points not selected as fgmax points.
    """
    
    import matplotlib.pyplot as plt
    import matplotlib.colors as colors
    import clawpack.visclaw.colormaps as colormaps

    print("Plotting %i fgmax_points... " % masked_topo.Z.count())
    
    if ax is None:
        plt.figure(500)
        plt.clf()
        ax = plt.subplot(111)

    if zmin is None:
        zmin = masked_topo.Z.min()
    
    if zmax is None:
        zmax = masked_topo.Z.max()
        
    if (cmap is None) or (norm is None):
        land_cmap = colormaps.make_colormap({ 0.0:[0.1,0.4,0.0],
                                             0.25:[0.0,1.0,0.0],
                                              0.5:[0.8,1.0,0.5],
                                              1.0:[0.8,0.5,0.2]})

        sea_cmap = colormaps.make_colormap({ 0.0:[0,0,1], 1.:[.8,.8,1]})

        cmap, norm = colormaps.add_colormaps((land_cmap, sea_cmap),
                                             data_limits=(zmin,zmax),
                                             data_break=0.)
    
    pc = plt.pcolormesh(masked_topo.X, masked_topo.Y, masked_topo.Z,
                    cmap=cmap, norm=norm)
    cb = plt.colorbar(pc, extend='both')
    if cb_label is not None:
        cb.set_label(cb_label)

    plt.gca().set_aspect(1./numpy.cos(masked_topo.Y.mean()*numpy.pi/180))
    
    x1 = masked_topo.X.min() - 10*(masked_topo.x[1]-masked_topo.x[0])
    x2 = masked_topo.X.max() + 10*(masked_topo.x[1]-masked_topo.x[0])
    y1 = masked_topo.Y.min() - 10*(masked_topo.y[1]-masked_topo.y[0])
    y2 = masked_topo.Y.max() + 10*(masked_topo.y[1]-masked_topo.y[0])
    plt.axis([x1,x2,y1,y2])
    
    plt.ticklabel_format(format='plain',useOffset=False)
    plt.xticks(rotation=20)
    if title is None:
        plt.title('%i fgmax points' % masked_topo.Z.count())
    else:
        plt.title(title)
        
    if png_fname is not None:
        plt.savefig(png_fname)
        print("Created %s" % png_fname)
        plt.close(500)
        
def lists_to_arrays(x_1d, y_1d, z_1d_arrays, dx, dy):
    """
    convert lists of fgmax points to uniform grids with extent given by the
    min and max of x_1d, y_1d.
    x,y values are assumed to lie on a grid with spacing dx,dy.
    Use masked arrays for missing values.
    """
    from numpy import ma
    x1 = x_1d.min(); x2 = x_1d.max()
    y1 = y_1d.min(); y2 = y_1d.max()
    mx = int(round((x2-x1)/dx)) + 1
    my = int(round((y2-y1)/dx)) + 1
    x = numpy.linspace(x1,x2,mx)
    y = numpy.linspace(y1,y2,my)
    X,Y = numpy.meshgrid(x,y,indexing='xy')
    Z_arrays = []
    for m,z_1d in enumerate(z_1d_arrays):
        if z_1d is None:
            Z = None
        else:
            Z = ma.masked_array(data=numpy.empty(X.shape), mask=True)
            for k in range(len(x_1d)):
                i = int(round((x_1d[k]-x1)/dx))
                j = int(round((y_1d[k]-y1)/dy))
                Z[j,i] = z_1d[k]
        Z_arrays.append(Z)
    return X,Y,Z_arrays

class FGmaxMaskedGrid(object):

    def __init__(self):
        
        # inputs for GeoClaw
        self.x = None
        self.y = None
        self.X = None
        self.Y = None
        self.Z = None  # for topo DEM values if available
        self.fgmax_point = None  # >0 if selected (1 or index?)
        self.force_dry_init = None  # =1 if wet, =0 if dry
        self.dx = None
        self.dy = None
        
        # outputs from GeoClaw fort.FG files
        self.level = None
        self.B = None
        self.h = None
        self.h_time = None
        self.s = None
        self.s_time = None
        self.hs = None
        self.hs_time = None
        self.hss = None
        self.hss_time = None
        self.hmin = None
        self.hmin_time = None
        self.arrival_time = None
        
        # possible derived quantities:
        self.dz = None
        self.B0 = None
        self.eta = None
        self.h_onshore = None
        self.id = ''  # identifier
        self.label = ''  # text for legend        
    
    def bounding_box(self):
        x1 = self.X.min()
        x2 = self.X.max()    
        y1 = self.Y.min()
        y2 = self.Y.max()
        return [x1,x2,y1,y2] 
                
    def convert_lists_to_arrays(self,fg,dx,dy):
        
        assert fg.point_style in [0,2,4], '*** Require fg.point_style in [0,2,4]'
        
        x_1d = fg.X
        y_1d = fg.Y
        print('+++ x_1d.shape = ', x_1d.shape)
        z_1d_arrays = [fg.level, fg.B, fg.h, fg.h_time, fg.s, fg.s_time, 
                       fg.hs, fg.hs_time, fg.hss, fg.hss_time, fg.hmin, 
                       fg.hmin_time, fg.arrival_time]
        num_arrays = len(z_1d_arrays)
        if fg.Z is not None:
            z_1d_arrays.append(fg.Z)
                       
        X,Y,Z_arrays = lists_to_arrays(x_1d, y_1d, z_1d_arrays, dx, dy)
        print('+++X.shape = ', X.shape)
        
        # unpack:
        self.level, self.B, self.h, self.h_time, self.s, self.s_time, \
                self.hs, self.hs_time, self.hss, self.hss_time, self.hmin, \
                self.hmin_time, self.arrival_time = Z_arrays[:num_arrays]
        self.X = X
        self.Y = Y
        if fg.Z is not None:
            self.Z = Z_arrays[-1]
            
            

def make_nc_input(fname_nc, fgm, force=False, verbose=True):

    import netCDF4
    import time
    import os
    
    if os.path.isfile(fname_nc):
        if force and verbose:
            print('Overwriting ', fname_nc)
        elif not force:
            print('*** netCDF file already exists, \n'\
                + '*** NOT overwriting '\
                + '--- use force==True to overwrite' )
            return -1
    
    with netCDF4.Dataset(fname_nc, 'w') as rootgrp:

        rootgrp.description = "fgmax data for " + fgm.id
        rootgrp.history = "Created with input data " + time.ctime(time.time())
        rootgrp.history += " in %s;  " % os.getcwd()
            
        if fgm.X is not None:
            x = fgm.X[0,:]
            lon = rootgrp.createDimension('lon', len(x))
            longitudes = rootgrp.createVariable('lon','f8',('lon',))
            longitudes[:] = x
            longitudes.units = 'degrees_east'
        else:
            if verbose: print('fgm.X is None, not adding x')
            
        if fgm.Y is not None:
            y = fgm.Y[:,0]
            lat = rootgrp.createDimension('lat', len(y))
            latitudes = rootgrp.createVariable('lat','f8',('lat',))
            latitudes[:] = y
            latitudes.units = 'degrees_north'
        else:
            if verbose: print('fgm.Y is None, not adding y')
            
        if fgm.Z is not None:
            Z = rootgrp.createVariable('Z','f4',('lat','lon',))
            Z[:,:] = fgm.Z.data  # include points that are not fgmax_points
            Z.units = 'meters'
        else:
            if verbose: print('fgm.Z is None, not adding')
            
        if fgm.fgmax_point is not None:
            fgmax_point_var = \
                rootgrp.createVariable('fgmax_point','u1',('lat','lon',))
            fgmax_point_var[:,:] = fgm.fgmax_point
        else:
            if verbose: print('fgm.fgmax_point is None, not adding')
            
        if fgm.force_dry_init is not None:
            force_dry_init = \
                rootgrp.createVariable('force_dry_init','u1',('lat','lon',))
            force_dry_init[:,:] = fgm.force_dry_init
        else:
            if verbose: print('fgm.force_dry_init is None, not adding')  

        print('Created %s' % fname_nc)            
        if verbose:
            print('History:  ', rootgrp.history) 
        return 0     
        
def write_nc_output(fname_nc, fgm, new=False, force=False, 
                    outdir='Unknown', verbose=True):

    import netCDF4
    import time
    import os
    from clawpack.clawutil.data import ClawData 
    
    fv = -9999.   # fill_value for netcdf4
    
    if new:
        # first create a new .nc file with X,Y,fgmax_point,force_dry_init:
        result = make_nc_input(fname_nc, fgm, force=force, verbose=verbose)
        if result == -1:
            print('*** make_nc_input failed, not appending output')
            return        
        
    if outdir is 'Unknown':
        # Cannot determine tfinal or run_finished time
        tfinal = fv
        run_finished = 'Unknown'
    else:
        claw = ClawData()
        claw.read(outdir+'/claw.data', force=True)
        tfinal = claw.tfinal
        
        try:
            mtime = os.path.getmtime(outdir+'/timing.txt')
            run_finished = time.ctime(mtime) 
        except:
            run_finished = 'Unknown'
            
    # add fgmax output results to existing file
    with netCDF4.Dataset(fname_nc, 'a') as rootgrp:
        if verbose:
            print('Appending data from fgm to nc file',fname_nc)
            print('        nc file description: ', rootgrp.description)
            print('        fgm.id: ', fgm.id)
        
        h = rootgrp.variables.get('h', None)
        if (h is not None) and (not force):
            print('*** netCDF file already contains output,\n'\
                + '*** NOT overwriting '\
                + '--- use force==True to overwrite' )
            return
                
        x = numpy.array(rootgrp.variables['lon'])
        y = numpy.array(rootgrp.variables['lat'])
        X,Y = numpy.meshgrid(x,y)
        Z = numpy.array(rootgrp.variables['Z'])
        fgmax_point = numpy.array(rootgrp.variables['fgmax_point'])
        bounding_box = [x.min(),x.max(),y.min(),y.max()]
        
        dx = x[1]-x[0]
        Xclose = numpy.allclose(fgm.X, X, atol=0.1*dx)
        Yclose = numpy.allclose(fgm.Y, Y, atol=0.1*dx)
        
        if (fgm.X.shape != X.shape):
            # for now raise an exception, might want to extent to allow
            # filling only part of input arrays
            print('*** Mismatch of fgm with data in nc file:')
            print('fgm.X.shape = ',fgm.X.shape)
            print('nc  X.shape = ',X.shape)
            print('fgm.bounding_box = ',fgm.bounding_box())
            print('nc  bounding_box = ',bounding_box)
            raise ValueError('*** Mismatch of fgm with data in nc file')
    
        Xclose = numpy.allclose(fgm.X, X, atol=0.1*dx)
        Yclose = numpy.allclose(fgm.Y, Y, atol=0.1*dx)
        if (not (Xclose and Yclose)):
            raise ValueError('*** Mismatch of fgm.X or fgm.Y with data in nc file')
            

        rootgrp.history += "Added output " + time.ctime(time.time())
        rootgrp.history += " in %s;  " % os.getcwd()
        
        rootgrp.tfinal = tfinal
        rootgrp.outdir = os.path.abspath(outdir)
        rootgrp.run_finished = run_finished
        
        fgmax_point = rootgrp.variables.get('fgmax_point', None)

        if fgm.dz is not None:
            try:
                dz = rootgrp.variables['dz']
            except:
                dz = rootgrp.createVariable('dz','f4',('lat','lon',),
                                            fill_value=fv)
            dz[:,:] = fgm.dz
            dz.units = 'meters'
            if verbose: print('    Adding fgm.dz to nc file')
        else:
            if verbose: print('fgm.dz is None, not adding')

        if fgm.B is not None:
            try:
                B = rootgrp.variables['B']
            except:
                B = rootgrp.createVariable('B','f4',('lat','lon',),
                                            fill_value=fv)
            B[:,:] = fgm.B
            B.units = 'meters'
            if verbose: print('    Adding fgm.B to nc file')
        else:
            if verbose: print('fgm.B is None, not adding')
                        
        if fgm.h is not None:
            try:
                h = rootgrp.variables['h']
            except:
                h = rootgrp.createVariable('h','f4',('lat','lon',),
                                            fill_value=fv)
            h[:,:] = fgm.h
            h.units = 'meters'
            if verbose: print('    Adding fgm.h to nc file')
        else:
            if verbose: print('fgm.h is None, not adding')
            
        if fgm.s is not None:        
            try:
                s = rootgrp.variables['s']
            except:
                s = rootgrp.createVariable('s','f4',('lat','lon',),
                                            fill_value=fv)
            s[:,:] = fgm.s
            s.units = 'meters/second'
            if verbose: print('    Adding fgm.s to nc file')
        else:
            if verbose: print('fgm.s is None, not adding')
            
        if fgm.hss is not None:        
            try:
                hss = rootgrp.variables['hss']
            except:
                hss = rootgrp.createVariable('hss','f4',('lat','lon',),
                                            fill_value=fv)
            hss[:,:] = fgm.hss
            hss.units = 'meters^3/sec^2'
            if verbose: print('    Adding fgm.hss to nc file')
        else:
            if verbose: print('fgm.hss is None, not adding')
            
        if fgm.hmin is not None:        
            try:
                hmin = rootgrp.variables['hmin']
            except:
                hmin = rootgrp.createVariable('hmin','f4',('lat','lon',),
                                            fill_value=fv)
            # negate hmin so that it is minimum flow depth min(h):
            hmin[:,:] = -fgm.hmin
            hmin.units = 'meters'
            if verbose: print('    Adding fgm.hmin to nc file')
        else:
            if verbose: print('fgm.hmin is None, not adding')
            
        if fgm.arrival_time is not None:        
            try:
                arrival_time = rootgrp.variables['arrival_time']
            except:
                arrival_time = rootgrp.createVariable('arrival_time','f4',('lat','lon',),
                                            fill_value=fv)
            arrival_time[:,:] = fgm.arrival_time
            arrival_time.units = 'seconds'
            if verbose: print('    Adding fgm.arrival_time to nc file')
        else:
            if verbose: print('fgm.arrival_time is None, not adding')
            
        print('Created %s' % fname_nc)
        if verbose:
            print('History:  ', rootgrp.history)
            print('\nMetadata:')
            print('  outdir:  ', rootgrp.outdir)
            print('  run_finished:  ', rootgrp.run_finished)
            print('  tfinal:  ', rootgrp.tfinal)

def read_nc(fname_nc, verbose=True):

    import netCDF4
    import time
    import os

                
    def get_as_array(var, fgmvar=None):
        if fgmvar is None:
            fgmvar = var
        a = rootgrp.variables.get(var, None)
        if a is not None:
            if verbose: print('    Loaded %s as fgm.%s' % (var,fgmvar))
            return numpy.array(a)
        else:
            if verbose: print('    Did not find %s for fgm.%s' \
                                % (var,fgmvar))
            return None
                    
    fgm = fgmax_tools.FGmaxMaskedGrid()

    with netCDF4.Dataset(fname_nc, 'r') as rootgrp:
        if verbose:
            print('Reading data to fgm from nc file',fname_nc)
            print('        nc file description: ', rootgrp.description)
            print('History:  ', rootgrp.history)


                
        x = get_as_array('lon','x')
        y = get_as_array('lat','y')
        
        if (x is None) or (y is None):
            print('*** Could not create grid')
            return None
            
        X,Y = numpy.meshgrid(x,y)
        fgm.X = X
        fgm.Y = Y
        if verbose:
            print('    Constructed fgm.X and fgm.Y')
        
        fgm.Z = get_as_array('Z')
        fgm.B = get_as_array('B')
        fgm.fgmax_point = get_as_array('fgmax_point') 
        fgm.dz = get_as_array('dz')
        fgm.h = get_as_array('h')
        fgm.s = get_as_array('s')
        fgm.hss = get_as_array('hss')
        fgm.hmin = get_as_array('hmin')
        fgm.arrival_time = get_as_array('arrival_time')
        fgm.force_dry_init = get_as_array('force_dry_init')
        
    if verbose:
        print('Returning FGmaxMaskedGrid object fgm')
    return fgm