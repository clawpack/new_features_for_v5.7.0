r"""
fgmax_tools module: $CLAW/geoclaw/src/python/geoclaw/fgmax_tools.py

Tools to specify an fgmax grid for keeping track of maximum flow depth, etc.
and to read in the fgmax output after doing a GeoClaw run.

"""

from __future__ import absolute_import
from __future__ import print_function
from clawpack.geoclaw import kmltools
import os
from numpy import sqrt, ma
import numpy
from six.moves import range
#from clawpack.geoclaw import topotools
import topotools # local version with masked write



class FGmaxGrid(object):

    """
    New class introduced in 5.2.1 to keep store information both about the
    fgmax input data and the output generated by a GeoClaw run.
    """

    def __init__(self):
        self.point_style = None
        self.npts = None
        self.nx = None
        self.ny = None
        self.n12 = None
        self.n23 = None
        self.tstart_max =  0.
        self.tend_max = 1.e10   # when to stop monitoring max values
        self.dt_check = 10.     # target time (sec) increment between updating 
                                # max values
        self.min_level_check = None    # which levels to monitor max on
        self.arrival_tol = 1.e-2       # tolerance for flagging arrival
        self.input_file_name = 'fgmax.txt'  # file for GeoClaw input data
        self.fgno = 1  # FG number
        self.xy_fname = None   # optional file name for separate list of points
                             # when point_style==0, distinct from header file
        self.write_xy_fname = False # controls whether xy_fname is created
                                    # by self.write_input_data, or only header 

        self.outdir = '_output'    # where to find GeoClaw output fort.FG*
        self.level = None
        self.X = None
        self.Y = None
        self.Z = None
        self.dx = None
        self.dy = None
        self.B = None
        self.h = None
        self.h_time = None
        self.s = None
        self.s_time = None
        self.hs = None
        self.hs_time = None
        self.hss = None
        self.hss_time = None
        self.hmin = None
        self.hmin_time = None
        self.arrival_time = None

    def read_input_data(self, input_file_name=None):
        r"""
        Read input data from a file like *fgmax.txt* that
        might have been created by *write_input_data*.
        """

        if input_file_name is not None:
            self.input_file_name = input_file_name
        fgmax_input = open(self.input_file_name).readlines()

        self.tstart_max = float(fgmax_input[0].split()[0])
        self.tend_max = float(fgmax_input[1].split()[0])
        self.dt_check = float(fgmax_input[2].split()[0])
        self.min_level_check = int(fgmax_input[3].split()[0])
        self.arrival_tol = float(fgmax_input[4].split()[0])
        self.point_style = point_style = int(fgmax_input[5].split()[0])
        if point_style == 0:
            self.npts = npts = int(fgmax_input[6].split()[0])
            if npts == 0:
                self.xy_fname = fgmax_input[7][1:-2]  # strip quotes
                xy = numpy.loadtxt(self.xy_fname, skiprows=1)
                self.X = xy[:,0]
                self.Y = xy[:,1]
                if xy.shape[1] > 2:
                    self.Z = xy[:,2]  # in case DEM values also stored in input file
                else:
                    self.Z = None
                self.npts = npts = len(self.X)
                print('Read %i x,y points from \n    %s' % (npts, self.xy_fname))
            else:
                self.X, self.Y = numpy.loadtxt(fgmax_input, skiprows=7, unpack=True)
        elif point_style == 1:
            self.npts = npts = int(fgmax_input[6].split()[0])
            self.x1 = float(fgmax_input[7].split()[0])
            self.y1 = float(fgmax_input[7].split()[1])
            self.x2 = float(fgmax_input[8].split()[0])
            self.y2 = float(fgmax_input[8].split()[1])
        elif point_style == 2:
            self.nx = nx = int(fgmax_input[6].split()[0])
            self.ny = ny = int(fgmax_input[6].split()[1])
            self.x1 = float(fgmax_input[7].split()[0])
            self.y1 = float(fgmax_input[7].split()[1])
            self.x2 = float(fgmax_input[8].split()[0])
            self.y2 = float(fgmax_input[8].split()[1])
        elif point_style == 3:
            self.n12 = n12 = int(fgmax_input[6].split()[0])
            self.n23 = n23 = int(fgmax_input[6].split()[1])
            self.x1 = float(fgmax_input[7].split()[0])
            self.y1 = float(fgmax_input[7].split()[1])
            self.x2 = float(fgmax_input[8].split()[0])
            self.y2 = float(fgmax_input[8].split()[1])
            self.x3 = float(fgmax_input[9].split()[0])
            self.y3 = float(fgmax_input[9].split()[1])
            self.x4 = float(fgmax_input[10].split()[0])
            self.y4 = float(fgmax_input[10].split()[1])
        elif point_style == 4:
            self.xy_fname = fgmax_input[6][1:-2]  # strip quotes
            ## Need to read in topotype 3 file and set self.npts
            # xy = numpy.loadtxt(self.xy_fname, skiprows=1)
            # self.X = xy[:,0]
            # self.Y = xy[:,1]
            # if xy.shape[1] > 2:
            #     self.Z = xy[:,2]  # in case DEM values also stored in input file
            # else:
            #     self.Z = None
            # self.npts = npts = len(self.X)
            # print('Read %i x,y points from \n    %s' % (npts, self.xy_fname))

    def write_input_data(self, input_file_name=None):
        r"""
        Write input data to a file like *fgmax.txt* that
        will be read in by GeoClaw as input data.
        """

        if input_file_name is not None:
            self.input_file_name = input_file_name

        print("---------------------------------------------- ")
        point_style = self.point_style
        if point_style not in [0,1,2,3,4]:
            raise NotImplementedError("make_fgmax not implemented for point_style %i" \
                % point_style)

        # write header, independent of point_style:
        fid = open(self.input_file_name,'w')
        fid.write("%16.10e            # tstart_max\n"  % self.tstart_max)
        fid.write("%16.10e            # tend_max\n"  % self.tend_max)
        fid.write("%16.10e            # dt_check\n" % self.dt_check)
        fid.write("%i %s              # min_level_check\n" \
                            % (self.min_level_check,16*" "))

        fid.write("%16.10e            # arrival_tol\n" % self.arrival_tol)
        fid.write("%i %s              # point_style\n" \
                            % (self.point_style,16*" "))


        if point_style == 0:
            if self.xy_fname is not None:
                fid.write("0         # npts==0 ==> points in this file:\n")
                fid.write("'%s'\n" % self.xy_fname)
                print("Created header file only, points should be in file:")
                print("   %s" % self.xy_fname)
                if self.write_xy_fname:
                    if self.Z is not None:
                        xydata = numpy.vstack([self.X,self.Y,self.Z]).T
                    else:
                        xydata = numpy.vstack([self.X,self.Y])
                    numpy.savetxt(self.xy_fname, xydata, 
                                  header='%8i' % len(self.X), 
                                  comments='', fmt='%24.14e')
            else:
                # list of points
                npts = self.npts
            
                print("Creating unstructured grid of %s points" % npts)
            
                fid.write("%i                 # npts\n" % (npts))
                for k in range(npts):
                    fid.write("%22.12f   %22.12f \n" % (self.X[k],self.Y[k]))
            fid.close()
            
            print("Created file ", self.input_file_name)
            

        elif point_style==1:
            # 1d transect of points
            x1,x2 = self.x1, self.x2
            y1,y2 = self.y1, self.y2
            if self.npts is None:
                dx = self.dx
                npts = int(round(sqrt((x2-x1)**2 + (y2-y1)**2)/dx)) + 1
                if abs((npts-1)*dx + x1 - x2) > 1e-6:
                    print("Warning: abs((npts-1)*dx + x1 - x2) = ", \
                          abs((npts-1)*dx + x1 - x2))
                    x2 = x1 + dx*(npts-1)
                    y2 = y1 + dx*(npts-1)
                    print("         resetting x2 to %g" % x2)
                    print("         resetting y2 to %g" % y2)
            else:
                npts = self.npts
                dx = sqrt((x2-x1)**2 + (y2-y1)**2)/(npts+1.)
                if self.dx is not None:
                    print("*** Warning: dx specified over-ridden by: ",dx)
        
        
            print("Creating 1d fixed grid with %s points" % npts)
            print("   dx = %g" % dx)
        
        
            fid.write("%i                 # npts\n" % (npts))
            fid.write("%g   %g            # x1, y1\n" % (x1,y1))
            fid.write("%g   %g            # x2, y2\n" % (x2,y2))
            fid.close()
            
        
            print("Created file ", self.input_file_name)
            print("   specifying fixed grid with %i points equally spaced from " \
                    % npts)
            print("   (%g,%g)  to  (%g,%g)" % (x1,y1,x2,y2))
            
            # not yet implemented:
            #fname_root = os.path.splitext(self.input_file_name)[0]
            #kml_file = fname_root + '.kml'
            #kmltools.line2kml(xy, kml_file, fname_root, color='8888FF')

        if point_style == 2:
            # 2d grid of points
            x1,x2 = self.x1, self.x2
            y1,y2 = self.y1, self.y2
            if self.nx is None:
                dx = self.dx
                nx = int(round((x2-x1)/dx)) + 1  
                if abs((nx-1)*dx + x1 - x2) > 1e-6:
                    print("Warning: abs((nx-1)*dx + x1 - x2) = ", \
                          abs((nx-1)*dx + x1 - x2))
                    print("         old x2: %22.16e" % x2)
                    x2 = x1 + dx*(nx-1)
                    print("         resetting x2 to %22.16e" % x2)
            else:
                nx = self.nx
                dx = (x2-x1)/(nx+1.)
                if self.dx is not None:
                    print("*** Warning: dx specified over-ridden by: ",dx)
        
            if self.ny is None:
                dy = self.dy
                if dy is None:
                    dy = dx
                ny = int(round((y2-y1)/dy)) + 1  
                if abs((ny-1)*dy + y1 - y2) > 1e-6:
                    print("Warning: abs((ny-1)*dy + y1 - y2) = ", \
                          abs((ny-1)*dy + y1 - y2))
                    print("         old y2: %22.16e" % y2)
                    y2 = y1 + dy*(ny-1)
                    print("         resetting y2 to %22.16e" % y2)
            else:
                ny = self.ny
                dy = (y2-y1)/(ny+1.)
                if self.dy is not None:
                    print("*** Warning: dy specified over-ridden by: ",dy)
        
        
            npts = nx*ny
        
        
            fid.write("%i  %i %s          # nx,ny\n" \
                                % (nx,ny,10*" "))
            fid.write("%16.10e   %20.10e            # x1, y1\n" % (x1,y1))
            fid.write("%16.10e   %20.10e            # x2, y2\n" % (x2,y2))
            fid.close()
            
        
            print("Created file ", self.input_file_name)
            print("   specifying fixed grid with shape %i by %i, with  %i points" \
                    % (nx,ny,npts))
            print("   lower left  = (%15.10f,%15.10f)" % (x1,y1))
            print("   upper right = (%15.10f,%15.10f)" % (x2,y2))
            print("   dx = %15.10e,  dy = %15.10e" % (dx,dy))
        
            xy = [x1,x2,y1,y2]
            fname_root = os.path.splitext(self.input_file_name)[0]
            kml_file = fname_root + '.kml'
            kmltools.box2kml(xy, kml_file, fname_root, color='8888FF')

        elif point_style==3:
            # arbitrary quadrilateral
            x1,x2 = self.x1, self.x2
            y1,y2 = self.y1, self.y2
            x3,x4 = self.x3, self.x4
            y3,y4 = self.y3, self.y4
            if self.n12 is None:
                raise NotImplementedError("Need to set n12 and n23")
            else:
                npts = self.n12 * self.n23
        
            fid.write("%i  %i %s          # self.n12,self.n23\n" \
                                % (self.n12,self.n23,10*" "))
            fid.write("%16.10e   %20.10e            # x1, y1\n" % (x1,y1))
            fid.write("%16.10e   %20.10e            # x2, y2\n" % (x2,y2))
            fid.write("%16.10e   %20.10e            # x3, y3\n" % (x3,y3))
            fid.write("%16.10e   %20.10e            # x4, y4\n" % (x4,y4))
            fid.close()
            
        
            print("Created file ", self.input_file_name)
            print("   specifying fixed grid as a quadrilateral")
            print("       %i by %i, with  %i points" \
                    % (self.n12,self.n23,npts))
            print("   corner 1 = (%15.10f,%15.10f)" % (x1,y1))
            print("   corner 2 = (%15.10f,%15.10f)" % (x2,y2))
            print("   corner 3 = (%15.10f,%15.10f)" % (x3,y3))
            print("   corner 4 = (%15.10f,%15.10f)" % (x4,y4))
            
            xy = [x1,y1,x2,y2,x3,y3,x4,y4]
            fname_root = os.path.splitext(self.input_file_name)[0]
            kml_file = fname_root + '.kml'
            kmltools.quad2kml(xy, kml_file, fname_root, color='8888FF')
            
        elif point_style == 4:
            if self.xy_fname is not None:
                fid.write("'%s'\n" % self.xy_fname)
                print("Created header file only, points should be in file:")
                print("   %s" % self.xy_fname)
                fid.close()

    def read_output(self, fgno=None, outdir=None):
        r"""
        Read the GeoClaw results on the fgmax grid numbered *fgno*.
        """
    
        if self.point_style is None:
            raise IOError("*** point_style is not set, need to read input?")
        point_style = self.point_style

        if fgno is not None:
            self.fgno = fgno
        if outdir is not None:
            self.outdir = outdir
    
        # try new style, e.g. fort.FG0001.valuemax
        fname1 = os.path.join(self.outdir, 'fort.FG%s.valuemax' \
                % str(self.fgno).zfill(4))
        if os.path.isfile(fname1):
            fname_style = 'new'
            fname = fname1
        else:
            # try old style, e.g. fort.FG1.valuemax
            fname2 = os.path.join(self.outdir, 'fort.FG%s.valuemax' \
                % str(self.fgno))
            fname_style = 'old'
            fname = fname2
            if not os.path.isfile(fname2):
                raise IOError("File not found: %s or %s" % (fname1,fname2))

        print("Reading %s ..." % fname)
        d = numpy.loadtxt(fname)
        
        if point_style == 4:
            self.npts = d.shape[0]
            print('+++ point_style == 4, found %i points ' % self.npts)
    
        if fname_style == 'new':
            fname = os.path.join(self.outdir, 'fort.FG%s.aux1' \
                    % str(self.fgno).zfill(4))
        else:
            fname = os.path.join(self.outdir, 'fort.FG%s.aux1' \
                    % str(self.fgno))

        if not os.path.isfile(fname):
            raise IOError("File not found: %s" % fname)

        print("Reading %s ..." % fname)
        daux = numpy.loadtxt(fname)
    
        ncols = d.shape[1]  
        if ncols not in [6,8,14]:
            raise IOError("*** Unexpected number of columns %s in file %s" \
                    % (ncols, fname))
    
        ind_x = 0
        ind_y = 1
        ind_level = 2
        ind_h = 3
        if ncols == 6:
            ind_h_time = 4
            ind_arrival_time = 5
        elif ncols == 8:
            ind_s = 4
            ind_h_time = 5
            ind_s_time = 6
            ind_arrival_time = 7
        elif ncols == 14:
            ind_s = 4
            ind_hs = 5
            ind_hss = 6
            ind_hmin = 7
            ind_h_time = 8
            ind_s_time = 9
            ind_hs_time = 10
            ind_hss_time = 11
            ind_hmin_time = 12
            ind_arrival_time = 13
    
        if point_style in [0,1,4]:
            fg_shape = (self.npts,)
        elif point_style == 2:
            fg_shape = (self.nx,self.ny)
        elif point_style == 3:
            fg_shape = (self.n12,self.n23)
        else:
            raise NotImplementedError("Not implemented for point_style %s" \
                % point_style)
    
        X = numpy.reshape(d[:,0],fg_shape,order='F')
        Y = numpy.reshape(d[:,1],fg_shape,order='F')
        y0 = 0.5*(Y.min() + Y.max())   # mid-latitude for scaling plots
        h = numpy.reshape(d[:,ind_h],fg_shape,order='F')
    
        # AMR level used for each fgmax value:
        level = numpy.reshape(d[:,ind_level].astype('int'),fg_shape,order='F')
        
        topo = []
        nlevels = daux.shape[1]
        for i in range(2,nlevels):
            topoi = numpy.reshape(daux[:,i],fg_shape,order='F')
            topoi = ma.masked_where(topoi < -1e50, topoi)
            topo.append(topoi)
    
        B = ma.masked_where(level==0, topo[0])  # level==0 ==> never updated
        levelmax = level.max()
        for i in range(levelmax):
            B = numpy.where(level==i+1, topo[i], B)
    
        mask = (h < -1e50)  # points that were never set
        B = ma.masked_where(mask, B)
        h = ma.masked_where(mask, h)

        def set_q_time(ind_q, ind_q_time):  
            q = numpy.reshape(d[:,ind_q],fg_shape,order='F')
            q = ma.masked_where(mask,q) 
            q_time = numpy.reshape(d[:,ind_q_time],fg_shape,order='F')  
            q_time = ma.masked_where(mask, q_time)      
            return q, q_time
    
        self.h, self.h_time = set_q_time(ind_h, ind_h_time)
        if ncols > 6:
            self.s, self.s_time = set_q_time(ind_s, ind_s_time)
        if ncols > 8:
            self.hs, self.hs_time = set_q_time(ind_hs, ind_hs_time)
            self.hss, self.hss_time = set_q_time(ind_hss, ind_hss_time)
            self.hmin, self.hmin_time = set_q_time(ind_hmin, ind_hmin_time)
    
        # last column is arrival times:
        arrival_time = numpy.reshape(d[:,ind_arrival_time],fg_shape,order='F')
        arrival_time = ma.masked_where(arrival_time < -1e50, arrival_time)  
        arrival_time = ma.masked_where(mask, arrival_time)
        self.arrival_time = arrival_time
    
        self.level = level
        self.X = X
        self.Y = Y
        self.B = B
        self.h = h
    

def adjust_fgmax_1d(x1_desired, x2_desired, x1_domain, dx):
    """
    :Input:
     - x1_desired, x2_desired: approximate desired limits of fgmax grid
     - x1_domain:  lower edge of computational domain
     - dx: Mesh spacing on fine grid that fgmax grid should conform to
    :Output:
     - x1_new, x2_new: limits to set so (x2-x1) is integer multiple
       of dx and points are at cell centers of computational grid
     - npoints: number of points
    """

    i1 = numpy.floor((x1_desired-x1_domain - 0.5*dx)/dx)
    x1_new = x1_domain + (i1 + 0.5)*dx 
    i2 = numpy.floor((x2_desired-x1_domain + 0.5*dx)/dx)
    x2_new = x1_domain + (i2 + 0.5)*dx 
    npoints = int(i2 - i1) + 1
    return x1_new, x2_new, npoints


def adjust_fgmax_grid(x1_desired, x2_desired, x1_domain, dx,
                      y1_desired, y2_desired, y1_domain, dy=None, verbose=True):

    
    if dy == None:
        dy = dx

    x1_new, x2_new, nx = adjust_fgmax_1d(x1_desired, x2_desired, x1_domain, dx)
    y1_new, y2_new, ny = adjust_fgmax_1d(y1_desired, y2_desired, y1_domain, dy)

    if verbose:
        print("x:")
        print("  moved %17.12f to %17.12f by %g" % (x1_desired, x1_new, abs(x1_desired-x1_new)))
        print("  moved %17.12f to %17.12f by %g" % (x2_desired, x2_new, abs(x2_desired-x2_new)))
        print("y:")
        print("  moved %17.12f to %17.12f by %g" % (y1_desired, y1_new, abs(y1_desired-y1_new)))
        print("  moved %17.12f to %17.12f by %g" % (y2_desired, y2_new, abs(y2_desired-y2_new)))
        #print "  "
        #print "fg.nx = %g" % nx
        #print "fg.ny = %g" % ny
        #print "fg.x1 = %17.12f" % x1_new
        #print "fg.x2 = %17.12f" % x2_new
        #print "fg.y1 = %17.12f" % y1_new
        #print "fg.y2 = %17.12f" % y2_new
    return x1_new, x2_new, nx, y1_new, y2_new, ny


def make_fgmax_points_from_topo(topo, zmin=-1e10, zmax=1e10,
                                extent='all', polygon=None, coarsen=1):
    
    """
    `polygon` can be a convex polygon of class shapely.geometry.polygon.Polygon,
    in which case only points that lie in both the xy extent specified by
    `extent` and in `polygon` will be considered.
    """

    if polygon:
        from shapely.geometry import Point
    
    fg = FGmaxGrid()
                            
    try:
        icoarsen, jcoarsen = coarsen  # if list
    except:
        icoarsen = jcoarsen = coarsen  # if single value
        
    if extent == 'all':
        x1,x2,y1,y2 = -360, 360, -90, 90
    elif extent == 'polygon':
        if polygon is not None:
            extent = polygon.bounds
            x1,x2,y1,y2 = extent  # unpack
        else:
            print("*** extent='polygon' ignored, no polygon")
    else:
        x1,x2,y1,y2 = extent  # unpack

    # find indices i,j for part of topo overlapping desired extent:
    iextent = [i for i,x in enumerate(topo.x) if (x1 <= x <= x2)]
    jextent = [j for j,y in enumerate(topo.y) if (y1 <= y <= y2)]
    
    try:
        i1 = iextent[0]
        i2 = iextent[-1] + 1
        j1 = jextent[0]
        j2 = jextent[-1] + 1
    except:
        raise ValueError('** extent does not overlap topo')

    X = topo.X[j1:j2:jcoarsen,i1:i2:icoarsen]
    Y = topo.Y[j1:j2:jcoarsen,i1:i2:icoarsen]
    Z = topo.Z[j1:j2:jcoarsen,i1:i2:icoarsen]
    
    X1d = numpy.ravel(X)
    Y1d = numpy.ravel(Y)
    Z1d = numpy.ravel(Z)

    print("From topo, found %i points in region" \
            % len(numpy.ravel(Z)))
    
    if polygon is not None:
        # mask values of Z array outside convex polygon
        points = [Point(xy) for xy in zip(X1d,Y1d)]
        inside = [polygon.contains(p) for p in points]
        Z1dm = ma.masked_where(numpy.logical_not(inside), Z1d)
    else:
        Z1dm = Z1d

    # mask values of Z array outside [zmin,zmax]:
    #Zm = ma.masked_where(numpy.logical_or(Z<zmin, Z>zmax), Z)
    #Z1dm = ma.ravel(Zm)
    Z1dm = ma.masked_where(numpy.logical_or(Z1dm<zmin, Z1dm>zmax), Z1dm)
    Zm = Z1dm.reshape(Z.shape)

    # find indices of Z1dm where not masked
    km = [kz for kz,z in enumerate(Z1dm.mask) if not z]
    
    print("Found %i points with z between zmin = %g and zmax = %g" \
            % (len(km), zmin, zmax))
    print("      in the region with extent %s" % str(extent))
    if polygon is not None:
        print("      and in the polygon:")
        for xy in polygon.boundary.coords:
            print(xy)
    
    fg.X = X1d[km]
    fg.Y = Y1d[km]
    fg.point_style = 0  # points
    fg.npts = len(fg.X)
    fg.Z = Z1d[km]  # also return the DEM topo value at each X,Y

    masked_topo = topotools.Topography()
    masked_topo._x = X[0,:]
    masked_topo._y = Y[:,0]
    masked_topo._Z = Zm  # replace by masked array
    masked_topo.generate_2d_topo()
    
    return fg, masked_topo


def plot_fgmax_points(X1,Y1,Z1,dx,dy,zmin=None,zmax=None,ax=None,
                      cmap=None,norm=None,alpha=1.,edgecolors='none',
                      title=None,cb_label=None,png_fname=None):
                      
    """
    This is *very* slow for lots of points since it creates and 
    plots a rectangle for each point, covering the appropriate area.
    
    Instead use plot_fgmax_masked_topo below for most purposes.
    """
    
    import matplotlib.pyplot as plt
    import matplotlib.colors as colors
    import clawpack.visclaw.colormaps as colormaps
    from matplotlib.collections import PatchCollection
    from matplotlib.patches import Rectangle

    print("Plotting %i fgmax_points... " % len(Z1))
    
    if ax is None:
        plt.figure(500)
        plt.clf()
        ax = plt.subplot(111)

    if zmin is None:
        zmin = Z1.min()
    
    if zmax is None:
        zmax = Z1.max()
        
    if (cmap is None) or (norm is None):
        land_cmap = colormaps.make_colormap({ 0.0:[0.1,0.4,0.0],
                                             0.25:[0.0,1.0,0.0],
                                              0.5:[0.8,1.0,0.5],
                                              1.0:[0.8,0.5,0.2]})

        sea_cmap = colormaps.make_colormap({ 0.0:[0,0,1], 1.:[.8,.8,1]})

        cmap, norm = colormaps.add_colormaps((land_cmap, sea_cmap),
                                             data_limits=(zmin,zmax),
                                             data_break=0.)


    rects = []
    for xi,yj,zij in zip(X1,Y1,Z1):
        rect = Rectangle((xi-dx/2.,yj-dy/2.), dx, dy)
        rects.append(rect)
        #ax.add_patch(rect)

    pc = PatchCollection(rects,  alpha=alpha, cmap=cmap, norm=norm,
                         edgecolor=edgecolors)
    pc.set_array(Z1)
    ax.add_collection(pc)
    cb = plt.colorbar(pc, extend='both')
    if cb_label is not None:
        cb.set_label(cb_label)

    plt.gca().set_aspect(1./numpy.cos(Y1.mean()*numpy.pi/180))
    
    x1 = X1.min() - 10*dx
    x2 = X1.max() + 10*dx
    y1 = Y1.min() - 10*dy
    y2 = Y1.max() + 10*dy
    plt.axis([x1,x2,y1,y2])
    
    plt.ticklabel_format(format='plain',useOffset=False)
    plt.xticks(rotation=20)
    if title is None:
        plt.title('%i fgmax points' % len(X1))
    else:
        plt.title(title)
        
    if png_fname is not None:
        plt.savefig(png_fname)
        print("Created %s" % png_fname)
        plt.close(500)
        

def plot_fgmax_masked_topo(masked_topo,zmin=None,zmax=None,ax=None,
                      cmap=None,norm=None,alpha=1.,edgecolors='none',
                      title=None,cb_label=None,png_fname=None):
                      
    """
    Plot the fgmax points based on the masked_topo array that is 
    masked at points not selected as fgmax points.
    """
    
    import matplotlib.pyplot as plt
    import matplotlib.colors as colors
    import clawpack.visclaw.colormaps as colormaps

    print("Plotting %i fgmax_points... " % masked_topo.Z.count())
    
    if ax is None:
        plt.figure(500)
        plt.clf()
        ax = plt.subplot(111)

    if zmin is None:
        zmin = masked_topo.Z.min()
    
    if zmax is None:
        zmax = masked_topo.Z.max()
        
    if (cmap is None) or (norm is None):
        land_cmap = colormaps.make_colormap({ 0.0:[0.1,0.4,0.0],
                                             0.25:[0.0,1.0,0.0],
                                              0.5:[0.8,1.0,0.5],
                                              1.0:[0.8,0.5,0.2]})

        sea_cmap = colormaps.make_colormap({ 0.0:[0,0,1], 1.:[.8,.8,1]})

        cmap, norm = colormaps.add_colormaps((land_cmap, sea_cmap),
                                             data_limits=(zmin,zmax),
                                             data_break=0.)
    
    pc = plt.pcolormesh(masked_topo.X, masked_topo.Y, masked_topo.Z,
                    cmap=cmap, norm=norm)
    cb = plt.colorbar(pc, extend='both')
    if cb_label is not None:
        cb.set_label(cb_label)

    plt.gca().set_aspect(1./numpy.cos(masked_topo.Y.mean()*numpy.pi/180))
    
    x1 = masked_topo.X.min() - 10*(masked_topo.x[1]-masked_topo.x[0])
    x2 = masked_topo.X.max() + 10*(masked_topo.x[1]-masked_topo.x[0])
    y1 = masked_topo.Y.min() - 10*(masked_topo.y[1]-masked_topo.y[0])
    y2 = masked_topo.Y.max() + 10*(masked_topo.y[1]-masked_topo.y[0])
    plt.axis([x1,x2,y1,y2])
    
    plt.ticklabel_format(format='plain',useOffset=False)
    plt.xticks(rotation=20)
    if title is None:
        plt.title('%i fgmax points' % masked_topo.Z.count())
    else:
        plt.title(title)
        
    if png_fname is not None:
        plt.savefig(png_fname)
        print("Created %s" % png_fname)
        plt.close(500)
        
def lists_to_arrays(x_1d, y_1d, z_1d_arrays, dx, dy):
    """
    convert lists of fgmax points to uniform grids with extent given by the
    min and max of x_1d, y_1d.
    x,y values are assumed to lie on a grid with spacing dx,dy.
    Use masked arrays for missing values.
    """
    from numpy import ma
    x1 = x_1d.min(); x2 = x_1d.max()
    y1 = y_1d.min(); y2 = y_1d.max()
    mx = int(round((x2-x1)/dx)) + 1
    my = int(round((y2-y1)/dx)) + 1
    x = numpy.linspace(x1,x2,mx)
    y = numpy.linspace(y1,y2,my)
    X,Y = numpy.meshgrid(x,y,indexing='xy')
    Z_arrays = []
    for m,z_1d in enumerate(z_1d_arrays):
        if z_1d is None:
            Z = None
        else:
            Z = ma.masked_array(data=numpy.empty(X.shape), mask=True)
            for k in range(len(x_1d)):
                i = int(round((x_1d[k]-x1)/dx))
                j = int(round((y_1d[k]-y1)/dy))
                Z[j,i] = z_1d[k]
        Z_arrays.append(Z)
    return X,Y,Z_arrays

class FGmaxMaskedGrid(object):

    def __init__(self):
        
        # inputs for GeoClaw
        self.x = None
        self.y = None
        self.X = None
        self.Y = None
        self.Z = None  # for topo DEM values if available
        self.fgmax_point = None  # >0 if selected (1 or index?)
        self.allow_wet_init = None  # =1 if wet, =0 if dry
        self.dx = None
        self.dy = None
        
        # outputs from GeoClaw fort.FG files
        self.level = None
        self.B = None
        self.h = None
        self.h_time = None
        self.s = None
        self.s_time = None
        self.hs = None
        self.hs_time = None
        self.hss = None
        self.hss_time = None
        self.hmin = None
        self.hmin_time = None
        self.arrival_time = None
        
        # possible derived quantities:
        self.dz = None
        self.B0 = None
        self.eta = None
        self.h_onshore = None
        self.id = ''  # identifier
        self.label = ''  # text for legend        
    
    def bounding_box(self):
        x1 = self.X.min()
        x2 = self.X.max()    
        y1 = self.Y.min()
        y2 = self.Y.max()
        return [x1,x2,y1,y2] 
                
    def convert_lists_to_arrays(self,fg,dx,dy):
        
        assert fg.point_style in [0,2,4], '*** Require fg.point_style in [0,2,4]'
        
        x_1d = fg.X
        y_1d = fg.Y
        print('+++ x_1d.shape = ', x_1d.shape)
        z_1d_arrays = [fg.level, fg.B, fg.h, fg.h_time, fg.s, fg.s_time, 
                       fg.hs, fg.hs_time, fg.hss, fg.hss_time, fg.hmin, 
                       fg.hmin_time, fg.arrival_time]
        num_arrays = len(z_1d_arrays)
        if fg.Z is not None:
            z_1d_arrays.append(fg.Z)
                       
        X,Y,Z_arrays = lists_to_arrays(x_1d, y_1d, z_1d_arrays, dx, dy)
        print('+++X.shape = ', X.shape)
        
        # unpack:
        self.level, self.B, self.h, self.h_time, self.s, self.s_time, \
                self.hs, self.hs_time, self.hss, self.hss_time, self.hmin, \
                self.hmin_time, self.arrival_time = Z_arrays[:num_arrays]
        self.X = X
        self.Y = Y
        if fg.Z is not None:
            self.Z = Z_arrays[-1]
            
            
